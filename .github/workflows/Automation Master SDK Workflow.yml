name: Automation Master Workflow

# Controls when the workflow will run
on:
  # Allows you to run this workflow from another workflow
  workflow_call:
    outputs:
      quality_gate: 
        description: "Results from Skyline Quality Gate."
        value: ${{ jobs.validate_skyline_quality_gate.outputs.quality }}
    inputs:
      referenceName:
        required: true
        type: string       
      runNumber:
        required: true
        type: string   
      referenceType:
        required: true
        type: string   
      repository:
        required: true
        type: string 
      owner:
        required: true
        type: string
      sonarCloudProjectName:
        required: true
        type: string
      debug:
        required: false
        type: boolean
    secrets:
      api-key:
        required: false
      sonarCloudToken:
        required: true
      azureToken:
        required: false

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  validate_skyline_quality_gate:
    name: SDK Skyline Quality Gate 
    runs-on: windows-latest
    env:
      detected-unit-tests: none
    outputs:
      quality: ${{ steps.quality-step.outputs.results }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Initialize
        run: |
          echo "workspace" ${{ github.workspace }}
          echo "ref name" ${{ inputs.referenceName }}
          echo "run number" ${{ inputs.runNumber }}
          echo "ref type" ${{ inputs.referenceType }}
          echo "repository" ${{ inputs.repository }}

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'zulu'

      - name: Find .sln file
        id: findSlnFile
        run: |
          echo solutionFilePath=$(find . -type f -name '*.sln') >> $GITHUB_OUTPUT
        shell: bash

      - name: Detect .csproj files
        id: detectCsprojFiles
        run: |
          $csprojFileCount = Get-ChildItem . -Recurse -File -Filter *.csproj | Measure-Object | Select-Object -ExpandProperty Count
          $result = "false"
          if($csprojFileCount -gt 0){ $result = "true" }
          Write-Output "csproj-file-present=$($result)" >> $Env:GITHUB_OUTPUT
        shell: pwsh

        # TODO: Refactor this in the future to a single stage with a loop that adds all the sources you specify.
      - name: Enable Skyline GitHub NuGet Registry
        if: inputs.owner == 'SkylineCommunications'
        run: |
          $SOURCE_NAME="PrivateGitHubNugets"
          $SOURCE_URL="https://nuget.pkg.github.com/SkylineCommunications/index.json"
          
          # Check if the source exists. If it does, update it.
          if (dotnet nuget list source | Select-String -Pattern $SOURCE_NAME) {
            Write-Host "Updating existing source $SOURCE_NAME."
            dotnet nuget update source $SOURCE_NAME --source $SOURCE_URL --username USERNAME --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text
          } else {
            Write-Host "Adding new source $SOURCE_NAME."
            dotnet nuget add source $SOURCE_URL --name $SOURCE_NAME --username USERNAME --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text
          }
        shell: pwsh

      - name: Enable Skyline Azure Cloud NuGet Registry
        env:
          AZURE_TOKEN_EXISTS: ${{ secrets.azureToken }}
        if: env.AZURE_TOKEN_EXISTS != null && inputs.owner == 'SkylineCommunications'
        run: |
          $SOURCE_NAME="CloudNuGets"
          $SOURCE_URL="https://pkgs.dev.azure.com/skyline-cloud/Cloud_NuGets/_packaging/CloudNuGet/nuget/v3/index.json"
          
          # Check if the source exists. If it does, update it.
          if (dotnet nuget list source | Select-String -Pattern $SOURCE_NAME) {
            Write-Host "Updating existing source $SOURCE_NAME."
            dotnet nuget update source $SOURCE_NAME --source $SOURCE_URL --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
          } else {
            Write-Host "Adding new source $SOURCE_NAME."
            dotnet nuget add source $SOURCE_URL --name $SOURCE_NAME --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
          }

      - name: Enable Skyline Azure Private NuGet Registry
        env:
          AZURE_TOKEN_EXISTS: ${{ secrets.azureToken }}
        if: env.AZURE_TOKEN_EXISTS != null && inputs.owner == 'SkylineCommunications'
        run: |
          $SOURCE_NAME="PrivateAzureNuGets"
          $SOURCE_URL="https://pkgs.dev.azure.com/skyline-cloud/_packaging/skyline-private-nugets/nuget/v3/index.json"
          
          # Check if the source exists. If it does, update it.
          if (dotnet nuget list source | Select-String -Pattern $SOURCE_NAME) {
            Write-Host "Updating existing source $SOURCE_NAME."
            dotnet nuget update source $SOURCE_NAME --source $SOURCE_URL --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
          } else {
            Write-Host "Adding new source $SOURCE_NAME."
            dotnet nuget add source $SOURCE_URL --name $SOURCE_NAME --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
          }

      - name: Install .NET Tools
        run: |
          dotnet tool install Skyline.DataMiner.CICD.Tools.Sbom --global --version 1.0.*

      - name: Building
        if: steps.detectCsprojFiles.outputs.csproj-file-present == 'true'
        run: dotnet build "${{ steps.findSlnFile.outputs.solutionFilePath }}" -p:DefineConstants="DCFv1%3BDBInfo%3BALARM_SQUASHING" --configuration Release -nodeReuse:false

      - name: Create package name
        if: inputs.referenceType == 'tag'
        id: packageName
        run: |
          $tempName = "${{ inputs.repository }}"
          $safeName = $tempName -replace '[\"\/\\<>|:*?]', '_'
          echo "name=$safeName" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Generate SBOM file
        if: inputs.referenceType == 'tag'
        run: |
          dataminer-sbom generate `
          --solution-path "${{ steps.findSlnFile.outputs.solutionFilePath }}" `
          --package-name "${{ steps.packageName.outputs.name }}" `
          --package-version "${{ inputs.referenceName }}" `
          --package-supplier "Skyline Communications" `
          --output "${{ github.workspace }}/SBOM" `
          --debug "${{ inputs.debug }}"

      - name: Upload SBOM file
        if: inputs.referenceType == 'tag'
        uses: actions/upload-artifact@v4
        with:
          name: SBOM
          path: "${{ github.workspace }}/SBOM/*.json"

      - name: Unit Tests
      # when not using MSTest you'll need to install coverlet.collector nuget in your test solutions
        id: unit-tests
        if: steps.detectCsprojFiles.outputs.csproj-file-present == 'true'
        run: dotnet test "${{ steps.findSlnFile.outputs.solutionFilePath }}" --filter TestCategory!=IntegrationTest --logger "trx;logfilename=unitTestResults.trx" --collect "XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura,opencover
        continue-on-error: true

      - name: Install SonarCloud scanner
        if: steps.detectCsprojFiles.outputs.csproj-file-present == 'true'
        run: |
          dotnet tool install dotnet-sonarscanner --global
  
      - name: Prepare SonarCloud Variables
        id: prepSonarCloudVar
        if: steps.detectCsprojFiles.outputs.csproj-file-present == 'true'
        run: |
          import os
          env_file = os.getenv('GITHUB_ENV')
          with open(env_file, "a") as myfile:
              myfile.write("lowerCaseOwner=" + str.lower("${{ inputs.owner }}"))
        shell: python

      - name: Get SonarCloud Status
        id: get-sonarcloud-status
        if: steps.detectCsprojFiles.outputs.csproj-file-present == 'true'
        run: |
          echo "sonarCloudProjectStatus=$(curl https://${{ secrets.sonarCloudToken }}@sonarcloud.io/api/qualitygates/project_status?projectKey=${{ inputs.sonarCloudProjectName }})" >> $env:GITHUB_OUTPUT
        continue-on-error: true

      - name: Trigger Initial Analysis
        if: steps.detectCsprojFiles.outputs.csproj-file-present == 'true' && fromJson(steps.get-sonarcloud-status.outputs.sonarCloudProjectStatus).projectStatus.status  == 'NONE'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.sonarCloudToken }}
        run: |
            dotnet sonarscanner begin /k:"${{ inputs.sonarCloudProjectName }}" /o:"${{ env.lowerCaseOwner }}" /d:sonar.token="${{ secrets.sonarCloudToken }}" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.cs.opencover.reportsPaths="**/TestResults/**/coverage.opencover.xml" /d:sonar.cs.vstest.reportsPaths="**/TestResults/**.trx"
            dotnet build "${{ steps.findSlnFile.outputs.solutionFilePath }}" -p:DefineConstants="DCFv1%3BDBInfo%3BALARM_SQUASHING" --configuration Release -nodeReuse:false
            dotnet sonarscanner end /d:sonar.token="${{ secrets.sonarCloudToken }}"
        continue-on-error: true
        
      - name: Analyze
        if: steps.detectCsprojFiles.outputs.csproj-file-present == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.sonarCloudToken }}
        run: |
            dotnet sonarscanner begin /k:"${{ inputs.sonarCloudProjectName }}" /o:"${{ env.lowerCaseOwner }}" /d:sonar.token="${{ secrets.sonarCloudToken }}" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.cs.opencover.reportsPaths="**/TestResults/**/coverage.opencover.xml" /d:sonar.cs.vstest.reportsPaths="**/TestResults/**.trx"
            dotnet build "${{ steps.findSlnFile.outputs.solutionFilePath }}" -p:DefineConstants="DCFv1%3BDBInfo%3BALARM_SQUASHING" --configuration Release -nodeReuse:false
            dotnet sonarscanner end /d:sonar.token="${{ secrets.sonarCloudToken }}"
        continue-on-error: true

      - name: SonarCloud Quality Gate check
        id: sonarcloud-quality-gate-check
        if: steps.detectCsprojFiles.outputs.csproj-file-present == 'true'
        uses: sonarsource/sonarqube-quality-gate-action@master
        with:
          scanMetadataReportFile: .sonarqube/out/.sonar/report-task.txt
        continue-on-error: true
        # Force to fail step after specific time.
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.sonarCloudToken }}
   
      - name: Quality Gate
        id: quality-step
        run: |
          if "${{ steps.detectCsprojFiles.outputs.csproj-file-present }}" == "false":
            print("Quality gate skipped as no .csproj files were detected.")
            exit(0)
          if "${{ steps.unit-tests.outcome }}" == "failure" or "${{ steps.sonarcloud-quality-gate-check.outcome }}" == "failure" or "${{ steps.sonarcloud-quality-gate-check.outputs.quality-gate-status }}" == "FAILED":
            print("Quality gate failed due to:")
          if "${{ steps.unit-tests.outcome }}" == "failure":
            print("- Test failures")
          if "${{ steps.sonarcloud-quality-gate-check.outcome }}" == "failure":
            print("- Could not retrieve SonarCloud quality gate status")
          if "${{ steps.sonarcloud-quality-gate-check.outputs.quality-gate-status }}" == "FAILED":
            print("- Code analysis quality gate failed")
          if "${{ steps.unit-tests.outcome }}" == "failure" or "${{ steps.sonarcloud-quality-gate-check.outcome }}" == "failure" or "${{ steps.sonarcloud-quality-gate-check.outputs.quality-gate-status }}" == "FAILED":
            exit(1)
        shell: python

  artifact_creation:
    name: Artifact Creation
    runs-on: ubuntu-latest
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      - name: Find .sln file
        id: findSlnFile        
        run: |
          echo solutionFilePath=$(find . -type f -name '*.sln') >> $GITHUB_OUTPUT
        shell: bash   
        
        # TODO: Refactor this in the future to a single stage with a loop that adds all the sources you specify.
      - name: Enable Skyline GitHub NuGet Registry
        if: inputs.owner == 'SkylineCommunications'
        run: |
          $SOURCE_NAME="PrivateGitHubNugets"
          $SOURCE_URL="https://nuget.pkg.github.com/SkylineCommunications/index.json"
          
          # Check if the source exists. If it does, update it.
          if (dotnet nuget list source | Select-String -Pattern $SOURCE_NAME) {
            Write-Host "Updating existing source $SOURCE_NAME."
            dotnet nuget update source $SOURCE_NAME --source $SOURCE_URL --username USERNAME --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text
          } else {
            Write-Host "Adding new source $SOURCE_NAME."
            dotnet nuget add source $SOURCE_URL --name $SOURCE_NAME --username USERNAME --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text
          }
        shell: pwsh
        
      - name: Enable Skyline Azure Cloud NuGet Registry
        env:
          AZURE_TOKEN_EXISTS: ${{ secrets.azureToken }}
        if: env.AZURE_TOKEN_EXISTS != null && inputs.owner == 'SkylineCommunications'
        run: |
          $SOURCE_NAME="CloudNuGets"
          $SOURCE_URL="https://pkgs.dev.azure.com/skyline-cloud/Cloud_NuGets/_packaging/CloudNuGet/nuget/v3/index.json"
          
          # Check if the source exists. If it does, update it.
          if (dotnet nuget list source | Select-String -Pattern $SOURCE_NAME) {
            Write-Host "Updating existing source $SOURCE_NAME."
            dotnet nuget update source $SOURCE_NAME --source $SOURCE_URL --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
          } else {
            Write-Host "Adding new source $SOURCE_NAME."
            dotnet nuget add source $SOURCE_URL --name $SOURCE_NAME --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
          }
        shell: pwsh

      - name: Enable Skyline Azure Private NuGet Registry
        env:
          AZURE_TOKEN_EXISTS: ${{ secrets.azureToken }}
        if: env.AZURE_TOKEN_EXISTS != null && inputs.owner == 'SkylineCommunications'
        run: |
          $SOURCE_NAME="PrivateAzureNuGets"
          $SOURCE_URL="https://pkgs.dev.azure.com/skyline-cloud/_packaging/skyline-private-nugets/nuget/v3/index.json"
          
          # Check if the source exists. If it does, update it.
          if (dotnet nuget list source | Select-String -Pattern $SOURCE_NAME) {
            Write-Host "Updating existing source $SOURCE_NAME."
            dotnet nuget update source $SOURCE_NAME --source $SOURCE_URL --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
          } else {
            Write-Host "Adding new source $SOURCE_NAME."
            dotnet nuget add source $SOURCE_URL --name $SOURCE_NAME --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
          }
        shell: pwsh

      - name: NuGet restore solution
        run: dotnet restore "${{ steps.findSlnFile.outputs.solutionFilePath }}"

      - name: Install .NET Tools
        run: |
          dotnet tool install -g Skyline.DataMiner.CICD.Tools.Packager --version 2.0.*
  
      - name: Create package name
        id: packageName
        run: |
          tempName="${{ inputs.repository }}"
          echo name=${tempName//[\"\/\\<>|:*?]/_} >> $GITHUB_OUTPUT
        shell: bash
  
      - name: Create dmapp package
        if: inputs.referenceType == 'tag'
        run: dataminer-package-create dmapp "${{ github.workspace }}" --type automation --version ${{ inputs.referenceName }} --output "${{ github.workspace }}" --name "${{ steps.packageName.outputs.name }}" --debug "${{ inputs.debug }}"
  
      - name: Create dmapp package
        if: inputs.referenceType != 'tag'
        run: dataminer-package-create dmapp "${{ github.workspace }}" --type automation --build-number ${{ inputs.runNumber }} --output "${{ github.workspace }}" --name "${{ steps.packageName.outputs.name }}" --debug "${{ inputs.debug }}"
  
      - uses: actions/upload-artifact@v4
        with:
          name: DataMiner Installation Package
          path: "${{ github.workspace }}/${{ steps.packageName.outputs.name }}.dmapp"

  auto_generate_catalog_yaml:
      name: Auto-Generating Catalog from GitHub
      if: ${{ inputs.referenceType == 'branch' &&  github.event_name != 'pull_request' }}
      runs-on: ubuntu-latest
      steps:
        # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
        - uses: actions/checkout@v4
       
          # TODO: Refactor this in the future to a single stage with a loop that adds all the sources you specify.
        - name: Enable Skyline GitHub NuGet Registry
          if: inputs.owner == 'SkylineCommunications'
          run: |
            $SOURCE_NAME="PrivateGitHubNugets"
            $SOURCE_URL="https://nuget.pkg.github.com/SkylineCommunications/index.json"
            
            # Check if the source exists. If it does, update it.
            if (dotnet nuget list source | Select-String -Pattern $SOURCE_NAME) {
              Write-Host "Updating existing source $SOURCE_NAME."
              dotnet nuget update source $SOURCE_NAME --source $SOURCE_URL --username USERNAME --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text
            } else {
              Write-Host "Adding new source $SOURCE_NAME."
              dotnet nuget add source $SOURCE_URL --name $SOURCE_NAME --username USERNAME --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text
            }
          shell: pwsh
          
        - name: Enable Skyline Azure Cloud NuGet Registry
          env:
            AZURE_TOKEN_EXISTS: ${{ secrets.azureToken }}
          if: env.AZURE_TOKEN_EXISTS != null && inputs.owner == 'SkylineCommunications'
          run: |
            $SOURCE_NAME="CloudNuGets"
            $SOURCE_URL="https://pkgs.dev.azure.com/skyline-cloud/Cloud_NuGets/_packaging/CloudNuGet/nuget/v3/index.json"
            
            # Check if the source exists. If it does, update it.
            if (dotnet nuget list source | Select-String -Pattern $SOURCE_NAME) {
              Write-Host "Updating existing source $SOURCE_NAME."
              dotnet nuget update source $SOURCE_NAME --source $SOURCE_URL --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
            } else {
              Write-Host "Adding new source $SOURCE_NAME."
              dotnet nuget add source $SOURCE_URL --name $SOURCE_NAME --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
            }
          shell: pwsh

        - name: Enable Skyline Azure Private NuGet Registry
          env:
            AZURE_TOKEN_EXISTS: ${{ secrets.azureToken }}
          if: env.AZURE_TOKEN_EXISTS != null && inputs.owner == 'SkylineCommunications'
          run: |
            $SOURCE_NAME="PrivateAzureNuGets"
            $SOURCE_URL="https://pkgs.dev.azure.com/skyline-cloud/_packaging/skyline-private-nugets/nuget/v3/index.json"
            
            # Check if the source exists. If it does, update it.
            if (dotnet nuget list source | Select-String -Pattern $SOURCE_NAME) {
              Write-Host "Updating existing source $SOURCE_NAME."
              dotnet nuget update source $SOURCE_NAME --source $SOURCE_URL --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
            } else {
              Write-Host "Adding new source $SOURCE_NAME."
              dotnet nuget add source $SOURCE_URL --name $SOURCE_NAME --username az --password ${{ secrets.azureToken }} --store-password-in-clear-text
            }
          shell: pwsh

        - name: Install .NET Tools
          run: |
            dotnet tool install -g Skyline.DataMiner.CICD.Tools.GitHubToCatalogYaml --version 2.0.*

        - name: Create or Extend Catalog.yml
          run: |
            github-to-catalog-yaml --workspace "${{ github.workspace }}" --github-token ${{ secrets.GITHUB_TOKEN }} --github-repository "${{ github.repository }}" --catalog-identifier "${{ vars.catalogIdentifier }}" --debug "${{ inputs.debug }}"
          
        - name: Check if catalog.yml or manifest.yml exists
          id: check_files
          shell: pwsh
          run: |
            if (Test-Path "${{ github.workspace }}/catalog.yml") {
              echo "catalogDetails=catalog.yml" >> $env:GITHUB_ENV
            }
            elseif (Test-Path "${{ github.workspace }}/manifest.yml") {
              echo "catalogDetails=manifest.yml" >> $env:GITHUB_ENV
            }
            else {
              Write-Host "No valid file found!"
              exit 1
            }
        
        - uses: actions/upload-artifact@v4
          if: env.catalogDetails != ''
          with:
            name: Catalog Details
            path: "${{ github.workspace }}/${{ env.catalogDetails }}"

        - name: Commit .githubtocatalog/auto-generated-catalog
          shell: pwsh
          run: |
            git config --global user.name "github-actions[bot]"
            git config --global user.email "github-actions[bot]@users.noreply.github.com"
            git add "${{ github.workspace }}/.githubtocatalog/auto-generated-catalog.yml"
            
            # Check if there are any changes to be committed
            git diff --staged --quiet
            if ($LASTEXITCODE -ne 0) {
              git commit -m "auto-generated"
            }
            else {
              Write-Host "No changes to commit."
            }
          
        - name: Push .githubtocatalog/auto-generated-catalog
          run: |
            git push
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  artifact_creation_registration:
    name: Artifact Registration and Upload
    if: inputs.referenceType == 'tag'
    runs-on: ubuntu-latest
    needs: [validate_skyline_quality_gate,artifact_creation]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Validate auto-generated catalog YAML file existence
        shell: pwsh
        run: |
          if (!(Test-Path "${{ github.workspace }}/.githubtocatalog/auto-generated-catalog.yml")) {
            Write-Host "Error: The auto-generated catalog YAML file was not found."
            Write-Host "Run the workflow on a branch before releasing, and ensure the tag points to the latest commit containing the auto-generated-catalog.yml file."
            exit 1
          }

      - name: Find branch
        id: findBranch
        run: |
          #!/bin/bash
          set -e  # Exit immediately if a command exits with a non-zero status.
          
          # Capture the branches containing the tag and process them
          branches="$(git branch --contains tags/${{ inputs.referenceName }} -r | grep 'origin/' | grep -vE '.*/.*/' | sed 's#origin/##' | paste -sd ",")"
          
          # Append to GitHub Actions output
          echo "branch=${branches}" >> $GITHUB_OUTPUT
        shell: bash 

      - name: Target Branch
        id: showResult
        run: echo "${{ steps.findBranch.outputs.branch }}"

      - name: Retrieve Installation Package
        id: retrieveInstallationPackage
        uses: actions/download-artifact@v4
        with:
          name: DataMiner Installation Package
          path: _DataMinerInstallationPackage

      - name: Find Installation package
        id: findInstallationPackage
        run: |
          IFS=$'\n'
          echo dmappPackageName=$(find _DataMinerInstallationPackage -type f -name '*.dmapp') >> $GITHUB_OUTPUT
          unset IFS
        shell: bash

      - name: Install .NET Tools
        run: |
          dotnet tool install -g Skyline.DataMiner.CICD.Tools.CatalogUpload --version 4.0.*
          dotnet tool install -g Skyline.DataMiner.CICD.Tools.GitHubToCatalogYaml --version 2.0.*
          dotnet tool install -g Skyline.DataMiner.CICD.Tools.Sbom --version 1.0.*

      - name: Retrieve SBOM file
        id: retrieveSbomFile
        uses: actions/download-artifact@v4
        with:
          name: SBOM
          path: _SBOM

      - name: Find SBOM file
        id: findSbomFile
        run: |
          IFS=$'\n'
          echo sbomFile=$(find _SBOM -type f -name '*.json') >> $GITHUB_OUTPUT
          unset IFS
        shell: bash

      - name: Add SBOM to package
        run: |
          dataminer-sbom add \
          --sbom-file "${{ steps.findSbomFile.outputs.sbomFile }}" \
          --package-file "${{ steps.findInstallationPackage.outputs.dmappPackageName }}" \
          --debug "${{ inputs.debug }}"

      - name: Create or Extend Catalog.yml
        run: |
          github-to-catalog-yaml --workspace "${{ github.workspace }}" --github-token ${{ secrets.GITHUB_TOKEN }} --github-repository "${{ github.repository }}" --catalog-identifier "${{ vars.catalogIdentifier }}" --debug "${{ inputs.debug }}"
       
      - name: Check if catalog.yml or manifest.yml exists
        id: check_files
        shell: pwsh
        run: |
          if (Test-Path "${{ github.workspace }}/catalog.yml") {
            echo "catalogDetails=catalog.yml" >> $env:GITHUB_ENV
          }
          elseif (Test-Path "${{ github.workspace }}/manifest.yml") {
            echo "catalogDetails=manifest.yml" >> $env:GITHUB_ENV
          }
          else {
            Write-Host "No valid file found!"
            exit 1
          }
      
      - uses: actions/upload-artifact@v4
        if: env.catalogDetails != ''
        with:
          name: Catalog Details
          path: "${{ github.workspace }}/${{ env.catalogDetails }}"

      - name: Upload to Catalog
        env:
          CICDIsForSkyline: "${{ inputs.owner == 'SkylineCommunications' }}"
        run: dataminer-catalog-upload with-registration --path-to-artifact "${{ steps.findInstallationPackage.outputs.dmappPackageName }}" --artifact-version ${{ inputs.referenceName }} --branch "${{ steps.findBranch.outputs.branch }}" --dm-catalog-token ${{ secrets.api-key }} --debug "${{ inputs.debug }}"
